#ifndef DPY_H
#define DPY_H

static const struct {
    int 	 size;
    const char	 file_data[23490 + 1];
} DisassembleSound = {
    23490 + 1,
    "#!/usr/bin/env python3\n"
    "from collections import namedtuple, defaultdict\n"
    "import tempfile\n"
    "import subprocess\n"
    "import uuid\n"
    "import json\n"
    "import os\n"
    "import re\n"
    "import struct\n"
    "import sys\n"
    "import mext\n"
    "\n"
    "TYPE_CTL = 1\n"
    "TYPE_TBL = 2\n"
    "\n"
    "\n"
    "class AifcEntry:\n"
    "    def __init__(self, data, book, loop):\n"
    "        self.name = None\n"
    "        self.data = data\n"
    "        self.book = book\n"
    "        self.loop = loop\n"
    "        self.tunings = []\n"
    "\n"
    "\n"
    "class SampleBank:\n"
    "    def __init__(self, name, data, offset):\n"
    "        self.offset = offset\n"
    "        self.name = name\n"
    "        self.data = data\n"
    "        self.entries = {}\n"
    "\n"
    "    def add_sample(self, offset, sample_size, book, loop):\n"
    "        assert sample_size % 2 == 0\n"
    "        if sample_size % 9 != 0:\n"
    "            assert sample_size % 9 == 1\n"
    "            sample_size -= 1\n"
    "\n"
    "        if offset in self.entries:\n"
    "            entry = self.entries[offset]\n"
    "            assert entry.book == book\n"
    "            assert entry.loop == loop\n"
    "            assert len(entry.data) == sample_size\n"
    "        else:\n"
    "            entry = AifcEntry(self.data[offset : offset + sample_size], book, loop)\n"
    "            self.entries[offset] = entry\n"
    "\n"
    "        return entry\n"
    "\n"
    "\n"
    "Sound = namedtuple(\"Sound\", [\"sample_addr\", \"tuning\"])\n"
    "Drum = namedtuple(\"Drum\", [\"name\", \"addr\", \"release_rate\", \"pan\", \"envelope\", \"sound\"])\n"
    "Inst = namedtuple(\n"
    "    \"Inst\",\n"
    "    [\n"
    "        \"name\",\n"
    "        \"addr\",\n"
    "        \"release_rate\",\n"
    "        \"normal_range_lo\",\n"
    "        \"normal_range_hi\",\n"
    "        \"envelope\",\n"
    "        \"sound_lo\",\n"
    "        \"sound_med\",\n"
    "        \"sound_hi\",\n"
    "    ],\n"
    ")\n"
    "Book = namedtuple(\"Book\", [\"order\", \"npredictors\", \"table\"])\n"
    "Loop = namedtuple(\"Loop\", [\"start\", \"end\", \"count\", \"state\"])\n"
    "Envelope = namedtuple(\"Envelope\", [\"name\", \"entries\"])\n"
    "Bank = namedtuple(\n"
    "    \"Bank\",\n"
    "    [\n"
    "        \"name\",\n"
    "        \"iso_date\",\n"
    "        \"sample_bank\",\n"
    "        \"insts\",\n"
    "        \"drums\",\n"
    "        \"all_insts\",\n"
    "        \"inst_list\",\n"
    "        \"envelopes\",\n"
    "        \"samples\",\n"
    "    ],\n"
    ")\n"
    "\n"
    "\n"
    "def align(val, al):\n"
    "    return (val + (al - 1)) & -al\n"
    "\n"
    "\n"
    "name_tbl = {}\n"
    "\n"
    "\n"
    "def gen_name(prefix, name_table=[]):\n"
    "    if prefix not in name_tbl:\n"
    "        name_tbl[prefix] = 0\n"
    "    ind = name_tbl[prefix]\n"
    "    name_tbl[prefix] += 1\n"
    "    if ind < len(name_table):\n"
    "        return name_table[ind]\n"
    "    return prefix + str(ind)\n"
    "\n"
    "\n"
    "def parse_bcd(data):\n"
    "    ret = 0\n"
    "    for c in data:\n"
    "        ret *= 10\n"
    "        ret += c >> 4\n"
    "        ret *= 10\n"
    "        ret += c & 15\n"
    "    return ret\n"
    "\n"
    "\n"
    "def serialize_f80(num):\n"
    "    num = float(num)\n"
    "    f64, = struct.unpack(\">Q\", struct.pack(\">d\", num))\n"
    "    f64_sign_bit = f64 & 2 ** 63\n"
    "    if num == 0.0:\n"
    "        if f64_sign_bit:\n"
    "            return b\"\\x80\" + b\"\\0\" * 9\n"
    "        else:\n"
    "            return b\"\\0\" * 10\n"
    "    exponent = (f64 ^ f64_sign_bit) >> 52\n"
    "    assert exponent != 0, \"can't handle denormals\"\n"
    "    assert exponent != 0x7FF, \"can't handle infinity/nan\"\n"
    "    exponent -= 1023\n"
    "    f64_mantissa_bits = f64 & (2 ** 52 - 1)\n"
    "    f80_sign_bit = f64_sign_bit << (80 - 64)\n"
    "    f80_exponent = (exponent + 0x3FFF) << 64\n"
    "    f80_mantissa_bits = 2 ** 63 | (f64_mantissa_bits << (63 - 52))\n"
    "    f80 = f80_sign_bit | f80_exponent | f80_mantissa_bits\n"
    "    return struct.pack(\">HQ\", f80 >> 64, f80 & (2 ** 64 - 1))\n"
    "\n"
    "\n"
    "def round_f32(num):\n"
    "    enc = struct.pack(\">f\", num)\n"
    "    for decimals in range(5, 20):\n"
    "        num2 = round(num, decimals)\n"
    "        if struct.pack(\">f\", num2) == enc:\n"
    "            return num2\n"
    "    return num\n"
    "\n"
    "\n"
    "def parse_sound(data):\n"
    "    sample_addr, tuning = struct.unpack(\">If\", data)\n"
    "    if sample_addr == 0:\n"
    "        assert tuning == 0\n"
    "        return None\n"
    "    return Sound(sample_addr, tuning)\n"
    "\n"
    "\n"
    "def parse_drum(data, addr):\n"
    "    name = gen_name(\"drum\")\n"
    "    release_rate, pan, loaded, pad = struct.unpack(\">BBBB\", data[:4])\n"
    "    assert loaded == 0\n"
    "    assert pad == 0\n"
    "    sound = parse_sound(data[4:12])\n"
    "    env_addr, = struct.unpack(\">I\", data[12:])\n"
    "    assert env_addr != 0\n"
    "    return Drum(name, addr, release_rate, pan, env_addr, sound)\n"
    "\n"
    "\n"
    "def parse_inst(data, addr):\n"
    "    name = gen_name(\"inst\")\n"
    "    loaded, normal_range_lo, normal_range_hi, release_rate, env_addr = struct.unpack(\n"
    "        \">BBBBI\", data[:8]\n"
    "    )\n"
    "    assert env_addr != 0\n"
    "    sound_lo = parse_sound(data[8:16])\n"
    "    sound_med = parse_sound(data[16:24])\n"
    "    sound_hi = parse_sound(data[24:])\n"
    "    if sound_lo is None:\n"
    "        assert normal_range_lo == 0\n"
    "    if sound_hi is None:\n"
    "        assert normal_range_hi == 127\n"
    "    return Inst(\n"
    "        name,\n"
    "        addr,\n"
    "        release_rate,\n"
    "        normal_range_lo,\n"
    "        normal_range_hi,\n"
    "        env_addr,\n"
    "        sound_lo,\n"
    "        sound_med,\n"
    "        sound_hi,\n"
    "    )\n"
    "\n"
    "\n"
    "def parse_loop(addr, bank_data):\n"
    "    start, end, count, pad = struct.unpack(\">IIiI\", bank_data[addr : addr + 16])\n"
    "    assert pad == 0\n"
    "    if count != 0:\n"
    "        state = struct.unpack(\">16h\", bank_data[addr + 16 : addr + 48])\n"
    "    else:\n"
    "        state = None\n"
    "    return Loop(start, end, count, state)\n"
    "\n"
    "\n"
    "def parse_book(addr, bank_data):\n"
    "    order, npredictors = struct.unpack(\">ii\", bank_data[addr : addr + 8])\n"
    "    assert order == 2\n"
    "    assert npredictors == 2\n"
    "    table_data = bank_data[addr + 8 : addr + 8 + 16 * order * npredictors]\n"
    "    table = []\n"
    "    for i in range(0, 16 * order * npredictors, 2):\n"
    "        table.append(struct.unpack(\">h\", table_data[i : i + 2])[0])\n"
    "    return Book(order, npredictors, table)\n"
    "\n"
    "\n"
    "def parse_sample(data, bank_data, sample_bank):\n"
    "    zero, addr, loop, book, sample_size = struct.unpack(\">IIIII\", data)\n"
    "    assert zero == 0\n"
    "    assert loop != 0\n"
    "    assert book != 0\n"
    "    loop = parse_loop(loop, bank_data)\n"
    "    book = parse_book(book, bank_data)\n"
    "    return sample_bank.add_sample(addr, sample_size, book, loop)\n"
    "\n"
    "\n"
    "def parse_envelope(addr, data_bank):\n"
    "    entries = []\n"
    "    while True:\n"
    "        delay, arg = struct.unpack(\">HH\", data_bank[addr : addr + 4])\n"
    "        entries.append((delay, arg))\n"
    "        addr += 4\n"
    "        if 1 <= (-delay) % 2 ** 16 <= 3:\n"
    "            break\n"
    "    return entries\n"
    "\n"
    "\n"
    "def parse_ctl(header, data, sample_bank, index):\n"
    "    name_tbl.clear()\n"
    "    name = \"{:02X}\".format(index)\n"
    "    num_instruments, num_drums, shared = struct.unpack(\">III\", header[:12])\n"
    "    date = parse_bcd(header[12:])\n"
    "    y = date // 10000\n"
    "    m = date // 100 % 100\n"
    "    d = date % 100\n"
    "    iso_date = \"{:02}-{:02}-{:02}\".format(y, m, d)\n"
    "    assert shared in [0, 1]\n"
    "    # print(\"{}: {}, {} + {}\".format(name, iso_date, num_instruments, num_drums))\n"
    "\n"
    "    drum_base_addr, = struct.unpack(\">I\", data[:4])\n"
    "    drum_addrs = []\n"
    "    if num_drums != 0:\n"
    "        assert drum_base_addr != 0\n"
    "        for i in range(num_drums):\n"
    "            drum_addr, = struct.unpack(\n"
    "                \">I\", data[drum_base_addr + i * 4 : drum_base_addr + i * 4 + 4]\n"
    "            )\n"
    "            assert drum_addr != 0\n"
    "            drum_addrs.append(drum_addr)\n"
    "    else:\n"
    "        assert drum_base_addr == 0\n"
    "\n"
    "    inst_base_addr = 4\n"
    "    inst_addrs = []\n"
    "    inst_list = []\n"
    "    for i in range(num_instruments):\n"
    "        inst_addr, = struct.unpack(\n"
    "            \">I\", data[inst_base_addr + i * 4 : inst_base_addr + i * 4 + 4]\n"
    "        )\n"
    "        if inst_addr == 0:\n"
    "            inst_list.append(None)\n"
    "        else:\n"
    "            inst_list.append(inst_addr)\n"
    "            inst_addrs.append(inst_addr)\n"
    "\n"
    "    inst_addrs.sort()\n"
    "    assert drum_addrs == sorted(drum_addrs)\n"
    "    if drum_addrs and inst_addrs:\n"
    "        assert max(inst_addrs) < min(drum_addrs)\n"
    "\n"
    "    assert len(set(inst_addrs)) == len(inst_addrs)\n"
    "    assert len(set(drum_addrs)) == len(drum_addrs)\n"
    "\n"
    "    insts = []\n"
    "    for inst_addr in inst_addrs:\n"
    "        insts.append(parse_inst(data[inst_addr : inst_addr + 32], inst_addr))\n"
    "\n"
    "    drums = []\n"
    "    for drum_addr in drum_addrs:\n"
    "        drums.append(parse_drum(data[drum_addr : drum_addr + 16], drum_addr))\n"
    "\n"
    "    env_addrs = set()\n"
    "    sample_addrs = set()\n"
    "    tunings = defaultdict(lambda: [])\n"
    "    for inst in insts:\n"
    "        for sound in [inst.sound_lo, inst.sound_med, inst.sound_hi]:\n"
    "            if sound is not None:\n"
    "                sample_addrs.add(sound.sample_addr)\n"
    "                tunings[sound.sample_addr].append(sound.tuning)\n"
    "        env_addrs.add(inst.envelope)\n"
    "    for drum in drums:\n"
    "        sample_addrs.add(drum.sound.sample_addr)\n"
    "        tunings[drum.sound.sample_addr].append(drum.sound.tuning)\n"
    "        env_addrs.add(drum.envelope)\n"
    "\n"
    "    # Put drums somewhere in the middle of the instruments to make sample\n"
    "    # addresses come in increasing order. (This logic isn't totally right,\n"
    "    # but it works for our purposes.)\n"
    "    all_insts = []\n"
    "    need_drums = len(drums) > 0\n"
    "    for inst in insts:\n"
    "        if need_drums and any(\n"
    "            s.sample_addr > drums[0].sound.sample_addr\n"
    "            for s in [inst.sound_lo, inst.sound_med, inst.sound_hi]\n"
    "            if s is not None\n"
    "        ):\n"
    "            all_insts.append(drums)\n"
    "            need_drums = False\n"
    "        all_insts.append(inst)\n"
    "\n"
    "    if need_drums:\n"
    "        all_insts.append(drums)\n"
    "\n"
    "    samples = {}\n"
    "    for addr in sorted(sample_addrs):\n"
    "        samples[addr] = parse_sample(data[addr : addr + 20], data, sample_bank)\n"
    "        samples[addr].tunings.extend(tunings[addr])\n"
    "\n"
    "    env_data = {}\n"
    "    used_env_addrs = set()\n"
    "    for addr in sorted(env_addrs):\n"
    "        env = parse_envelope(addr, data)\n"
    "        env_data[addr] = env\n"
    "        for i in range(align(len(env), 4)):\n"
    "            used_env_addrs.add(addr + i * 4)\n"
    "\n"
    "    # Unused envelopes\n"
    "    unused_envs = set()\n"
    "    if used_env_addrs:\n"
    "        for addr in range(min(used_env_addrs) + 4, max(used_env_addrs), 4):\n"
    "            if addr not in used_env_addrs:\n"
    "                unused_envs.add(addr)\n"
    "                stub_marker, = struct.unpack(\">I\", data[addr : addr + 4])\n"
    "                assert stub_marker == 0\n"
    "                env = parse_envelope(addr, data)\n"
    "                env_data[addr] = env\n"
    "                for i in range(align(len(env), 4)):\n"
    "                    used_env_addrs.add(addr + i * 4)\n"
    "\n"
    "    envelopes = {}\n"
    "    for addr in sorted(env_data.keys()):\n"
    "        env_name = gen_name(\"envelope\")\n"
    "        if addr in unused_envs:\n"
    "            env_name += \"_unused\"\n"
    "        envelopes[addr] = Envelope(env_name, env_data[addr])\n"
    "\n"
    "    return Bank(\n"
    "        name,\n"
    "        iso_date,\n"
    "        sample_bank,\n"
    "        insts,\n"
    "        drums,\n"
    "        all_insts,\n"
    "        inst_list,\n"
    "        envelopes,\n"
    "        samples,\n"
    "    )\n"
    "\n"
    "\n"
    "def parse_seqfile(data, filetype):\n"
    "    magic, num_entries = struct.unpack(\">HH\", data[:4])\n"
    "    assert magic == filetype\n"
    "    prev = align(4 + num_entries * 8, 16)\n"
    "    entries = []\n"
    "    for i in range(num_entries):\n"
    "        offset, length = struct.unpack(\">II\", data[4 + i * 8 : 4 + i * 8 + 8])\n"
    "        if filetype == TYPE_CTL:\n"
    "            assert offset == prev\n"
    "        else:\n"
    "            assert offset <= prev\n"
    "        prev = max(prev, offset + length)\n"
    "        entries.append((offset, length))\n"
    "    assert all(x == 0 for x in data[prev:])\n"
    "    return entries\n"
    "\n"
    "\n"
    "def parse_tbl(data, entries):\n"
    "    seen = {}\n"
    "    tbls = []\n"
    "    sample_banks = []\n"
    "    sample_bank_map = {}\n"
    "    for (offset, length) in entries:\n"
    "        if offset not in seen:\n"
    "            name = gen_name(\"sample_bank\")\n"
    "            seen[offset] = name\n"
    "            sample_bank = SampleBank(name, data[offset : offset + length], offset)\n"
    "            sample_banks.append(sample_bank)\n"
    "            sample_bank_map[name] = sample_bank\n"
    "        tbls.append(seen[offset])\n"
    "    return tbls, sample_banks, sample_bank_map\n"
    "\n"
    "\n"
    "class AifcWriter:\n"
    "    def __init__(self, out):\n"
    "        self.out = out\n"
    "        self.sections = []\n"
    "        self.total_size = 0\n"
    "\n"
    "    def add_section(self, tp, data):\n"
    "        assert isinstance(tp, bytes)\n"
    "        assert isinstance(data, bytes)\n"
    "        self.sections.append((tp, data))\n"
    "        self.total_size += align(len(data), 2) + 8\n"
    "\n"
    "    def add_custom_section(self, tp, data):\n"
    "        self.add_section(b\"APPL\", b\"stoc\" + self.pstring(tp) + data)\n"
    "\n"
    "    def pstring(self, data):\n"
    "        return bytes([len(data)]) + data + (b\"\" if len(data) % 2 else b\"\\0\")\n"
    "\n"
    "    def finish(self):\n"
    "        # total_size isn't used, and is regularly wrong. In particular, vadpcm_enc\n"
    "        # preserves the size of the input file...\n"
    "        self.total_size += 4\n"
    "        self.out.write(b\"FORM\" + struct.pack(\">I\", self.total_size) + b\"AIFC\")\n"
    "        for (tp, data) in self.sections:\n"
    "            self.out.write(tp + struct.pack(\">I\", len(data)))\n"
    "            self.out.write(data)\n"
    "            if len(data) % 2:\n"
    "                self.out.write(b\"\\0\")\n"
    "\n"
    "\n"
    "def write_aifc(entry, out):\n"
    "    writer = AifcWriter(out)\n"
    "    num_channels = 1\n"
    "    data = entry.data\n"
    "    assert len(data) % 9 == 0\n"
    "    if len(data) % 2 == 1:\n"
    "        data += b\"\\0\"\n"
    "    # (Computing num_frames this way makes it off by one when the data length\n"
    "    # is odd. It matches vadpcm_enc, though.)\n"
    "    num_frames = len(data) * 16 // 9\n"
    "    sample_size = 16  # bits per sample\n"
    "\n"
    "    if len(set(entry.tunings)) == 1:\n"
    "        sample_rate = 32000 * entry.tunings[0]\n"
    "    else:\n"
    "        # Some drum sounds in sample bank B don't have unique sample rates, so\n"
    "        # we have to guess. This doesn't matter for matching, it's just to make\n"
    "        # the sounds easy to listen to.\n"
    "        if min(entry.tunings) <= 0.5 <= max(entry.tunings):\n"
    "            sample_rate = 16000\n"
    "        elif min(entry.tunings) <= 1.0 <= max(entry.tunings):\n"
    "            sample_rate = 32000\n"
    "        elif min(entry.tunings) <= 1.5 <= max(entry.tunings):\n"
    "            sample_rate = 48000\n"
    "        elif min(entry.tunings) <= 2.5 <= max(entry.tunings):\n"
    "            sample_rate = 80000\n"
    "        else:\n"
    "            sample_rate = 16000 * (min(entry.tunings) + max(entry.tunings))\n"
    "\n"
    "    writer.add_section(\n"
    "        b\"COMM\",\n"
    "        struct.pack(\">hIh\", num_channels, num_frames, sample_size)\n"
    "        + serialize_f80(sample_rate)\n"
    "        + b\"VAPC\"\n"
    "        + writer.pstring(b\"VADPCM ~4-1\"),\n"
    "    )\n"
    "    writer.add_section(b\"INST\", b\"\\0\" * 20)\n"
    "    table_data = b\"\".join(struct.pack(\">h\", x) for x in entry.book.table)\n"
    "    writer.add_custom_section(\n"
    "        b\"VADPCMCODES\",\n"
    "        struct.pack(\">hhh\", 1, entry.book.order, entry.book.npredictors) + table_data,\n"
    "    )\n"
    "    writer.add_section(b\"SSND\", struct.pack(\">II\", 0, 0) + data)\n"
    "    if entry.loop.count != 0:\n"
    "        writer.add_custom_section(\n"
    "            b\"VADPCMLOOPS\",\n"
    "            struct.pack(\n"
    "                \">HHIIi16h\",\n"
    "                1,\n"
    "                1,\n"
    "                entry.loop.start,\n"
    "                entry.loop.end,\n"
    "                entry.loop.count,\n"
    "                *entry.loop.state\n"
    "            ),\n"
    "        )\n"
    "    writer.finish()\n"
    "\n"
    "\n"
    "def write_aiff(entry, filename):\n"
    "    temp = tempfile.NamedTemporaryFile(suffix=\".aifc\", delete=False)\n"
    "    try:\n"
    "        write_aifc(entry, temp)\n"
    "        temp.flush()\n"
    "        temp.close()\n"
    "        mext.aifc_decode(temp.name, filename)\n"
    "    finally:\n"
    "        temp.close()\n"
    "        os.remove(temp.name)\n"
    "\n"
    "\n"
    "# Modified from https://stackoverflow.com/a/25935321/1359139, cc by-sa 3.0\n"
    "class NoIndent(object):\n"
    "    def __init__(self, value):\n"
    "        self.value = value\n"
    "\n"
    "\n"
    "class NoIndentEncoder(json.JSONEncoder):\n"
    "    def __init__(self, *args, **kwargs):\n"
    "        super(NoIndentEncoder, self).__init__(*args, **kwargs)\n"
    "        self._replacement_map = {}\n"
    "\n"
    "    def default(self, o):\n"
    "        def ignore_noindent(o):\n"
    "            if isinstance(o, NoIndent):\n"
    "                return o.value\n"
    "            return self.default(o)\n"
    "\n"
    "        if isinstance(o, NoIndent):\n"
    "            key = uuid.uuid4().hex\n"
    "            self._replacement_map[key] = json.dumps(o.value, default=ignore_noindent)\n"
    "            return \"@@%s@@\" % (key,)\n"
    "        else:\n"
    "            return super(NoIndentEncoder, self).default(o)\n"
    "\n"
    "    def encode(self, o):\n"
    "        result = super(NoIndentEncoder, self).encode(o)\n"
    "        repl_map = self._replacement_map\n"
    "\n"
    "        def repl(m):\n"
    "            key = m.group()[3:-3]\n"
    "            return repl_map[key]\n"
    "\n"
    "        return re.sub(r\"\\\"@@[0-9a-f]*?@@\\\"\", repl, result)"
    "\n"
    "\n"
    "def inst_ifdef_json(bank_index, inst_index):\n"
    "    if bank_index == 7 and inst_index >= 13:\n"
    "        return NoIndent([\"VERSION_US\", \"VERSION_EU\"])\n"
    "    if bank_index == 8 and inst_index >= 16:\n"
    "        return NoIndent([\"VERSION_US\", \"VERSION_EU\"])\n"
    "    if bank_index == 10 and inst_index >= 14:\n"
    "        return NoIndent([\"VERSION_US\", \"VERSION_EU\"])\n"
    "    return None\n"
    "\n"
    "\n"
    "def main():\n"
    "    args = []\n"
    "    need_help = False\n"
    "    only_samples = False\n"
    "    only_samples_list = []\n"
    "    for a in sys.argv[1:]:\n"
    "        if a == \"--help\" or a == \"-h\":\n"
    "            need_help = True\n"
    "        elif a == \"--only-samples\":\n"
    "            only_samples = True\n"
    "        elif a.startswith(\"-\"):\n"
    "            print(\"Unrecognized option \" + a)\n"
    "            sys.exit(1)\n"
    "        elif only_samples:\n"
    "            only_samples_list.append(a)\n"
    "        else:\n"
    "            args.append(a)\n"
    "\n"
    "    expected_num_args = 2 if only_samples else 4\n"
    "    if need_help or len(args) != expected_num_args:\n"
    "        print(\n"
    "            \"Usage: {}\"\n"
    "            \" <.ctl file> <.tbl file>\"\n"
    "            \" (<samples outdir> <sound bank outdir> |\"\n"
    "            \" --only-samples file:index ...)\".format(sys.argv[0])\n"
    "        )\n"
    "        sys.exit(0 if need_help else 1)\n"
    "\n"
    "    ctl_data = open(args[0], \"rb\").read()\n"
    "    tbl_data = open(args[1], \"rb\").read()\n"
    "\n"
    "    if not only_samples:\n"
    "        samples_out_dir = args[2]\n"
    "        banks_out_dir = args[3]\n"
    "\n"
    "    ctl_entries = parse_seqfile(ctl_data, TYPE_CTL)\n"
    "    tbl_entries = parse_seqfile(tbl_data, TYPE_TBL)\n"
    "    assert len(ctl_entries) == len(tbl_entries)\n"
    "\n"
    "    tbls, sample_banks, sample_bank_map = parse_tbl(tbl_data, tbl_entries)\n"
    "\n"
    "    banks = []\n"
    "    for ((offset, length), sample_bank_name, index) in zip(\n"
    "        ctl_entries, tbls, range(len(ctl_entries))\n"
    "    ):\n"
    "        sample_bank = sample_bank_map[sample_bank_name]\n"
    "        entry = ctl_data[offset : offset + length]\n"
    "        banks.append(parse_ctl(entry[:16], entry[16:], sample_bank, index))\n"
    "\n"
    "    # Special mode used for asset extraction: generate aifc files, with paths\n"
    "    # given by command line arguments\n"
    "    if only_samples:\n"
    "        index_to_filename = {}\n"
    "        created_dirs = set()\n"
    "        for arg in only_samples_list:\n"
    "            filename, index = arg.rsplit(\":\", 1)\n"
    "            index_to_filename[int(index)] = filename\n"
    "        index = -1\n"
    "        for sample_bank in sample_banks:\n"
    "            offsets = sorted(set(sample_bank.entries.keys()))\n"
    "            for offset in offsets:\n"
    "                entry = sample_bank.entries[offset]\n"
    "                index += 1\n"
    "                if index in index_to_filename:\n"
    "                    filename = index_to_filename[index]\n"
    "                    dir = os.path.dirname(filename)\n"
    "                    if dir not in created_dirs:\n"
    "                        os.makedirs(dir, exist_ok=True)\n"
    "                        created_dirs.add(dir)\n"
    "                    write_aiff(entry, filename)\n"
    "        return\n"
    "\n"
    "    # Generate aiff files\n"
    "    for sample_bank in sample_banks:\n"
    "        dir = os.path.join(samples_out_dir, sample_bank.name)\n"
    "        os.makedirs(dir, exist_ok=True)\n"
    "\n"
    "        offsets = sorted(set(sample_bank.entries.keys()))\n"
    "        # print(sample_bank.name, len(offsets), 'entries')\n"
    "        offsets.append(len(sample_bank.data))\n"
    "\n"
    "        assert 0 in offsets\n"
    "        for offset, next_offset, index in zip(\n"
    "            offsets, offsets[1:], range(len(offsets))\n"
    "        ):\n"
    "            entry = sample_bank.entries[offset]\n"
    "            entry.name = \"{:02X}\".format(index)\n"
    "            size = next_offset - offset\n"
    "            assert size % 16 == 0\n"
    "            assert size - 15 <= len(entry.data) <= size\n"
    "            garbage = sample_bank.data[offset + len(entry.data) : offset + size]\n"
    "            if len(entry.data) % 2 == 1:\n"
    "                assert garbage[0] == 0\n"
    "            if next_offset != offsets[-1]:\n"
    "                # (The last chunk follows a more complex garbage pattern)\n"
    "                assert all(x == 0 for x in garbage)\n"
    "            filename = os.path.join(dir, entry.name + \".aiff\")\n"
    "            write_aiff(entry, filename)\n"
    "\n"
    "    # Generate sound bank .json files\n"
    "    os.makedirs(banks_out_dir, exist_ok=True)\n"
    "    for bank_index, bank in enumerate(banks):\n"
    "        filename = os.path.join(banks_out_dir, bank.name + \".json\")\n"
    "        with open(filename, \"w\") as out:\n"
    "\n"
    "            def sound_to_json(sound):\n"
    "                entry = bank.samples[sound.sample_addr]\n"
    "                if len(set(entry.tunings)) == 1:\n"
    "                    return entry.name\n"
    "                return {\"sample\": entry.name, \"tuning\": round_f32(sound.tuning)}\n"
    "\n"
    "            bank_json = {\n"
    "                \"date\": bank.iso_date,\n"
    "                \"sample_bank\": bank.sample_bank.name,\n"
    "                \"envelopes\": {},\n"
    "                \"instruments\": {},\n"
    "                \"instrument_list\": [],\n"
    "            }\n"
    "            addr_to_name = {}\n"
    "\n"
    "            # Envelopes\n"
    "            for env in bank.envelopes.values():\n"
    "                env_json = []\n"
    "                for (delay, arg) in env.entries:\n"
    "                    if delay == 0:\n"
    "                        ins = \"stop\"\n"
    "                        assert arg == 0\n"
    "                    elif delay == 2 ** 16 - 1:\n"
    "                        ins = \"hang\"\n"
    "                        assert arg == 0\n"
    "                    elif delay == 2 ** 16 - 2:\n"
    "                        ins = [\"goto\", arg]\n"
    "                    elif delay == 2 ** 16 - 3:\n"
    "                        ins = \"restart\"\n"
    "                        assert arg == 0\n"
    "                    else:\n"
    "                        ins = [delay, arg]\n"
    "                    env_json.append(NoIndent(ins))\n"
    "                bank_json[\"envelopes\"][env.name] = env_json\n"
    "\n"
    "            # Instruments/drums\n"
    "            for inst_index, inst in enumerate(bank.all_insts):\n"
    "                if isinstance(inst, Inst):\n"
    "                    inst_json = {\n"
    "                        \"ifdef\": inst_ifdef_json(bank_index, inst_index),\n"
    "                        \"release_rate\": inst.release_rate,\n"
    "                        \"normal_range_lo\": inst.normal_range_lo,\n"
    "                        \"normal_range_hi\": inst.normal_range_hi,\n"
    "                        \"envelope\": bank.envelopes[inst.envelope].name,\n"
    "                    }\n"
    "\n"
    "                    if inst_json[\"ifdef\"] is None:\n"
    "                        del inst_json[\"ifdef\"]\n"
    "\n"
    "                    if inst.sound_lo is not None:\n"
    "                        inst_json[\"sound_lo\"] = NoIndent(sound_to_json(inst.sound_lo))\n"
    "                    else:\n"
    "                        del inst_json[\"normal_range_lo\"]\n"
    "\n"
    "                    inst_json[\"sound\"] = NoIndent(sound_to_json(inst.sound_med))\n"
    "\n"
    "                    if inst.sound_hi is not None:\n"
    "                        inst_json[\"sound_hi\"] = NoIndent(sound_to_json(inst.sound_hi))\n"
    "                    else:\n"
    "                        del inst_json[\"normal_range_hi\"]\n"
    "\n"
    "                    bank_json[\"instruments\"][inst.name] = inst_json\n"
    "                    addr_to_name[inst.addr] = inst.name\n"
    "\n"
    "                else:\n"
    "                    assert isinstance(inst, list)\n"
    "                    drums_list_json = []\n"
    "                    for drum in inst:\n"
    "                        drum_json = {\n"
    "                            \"release_rate\": drum.release_rate,\n"
    "                            \"pan\": drum.pan,\n"
    "                            \"envelope\": bank.envelopes[drum.envelope].name,\n"
    "                            \"sound\": sound_to_json(drum.sound),\n"
    "                        }\n"
    "                        drums_list_json.append(NoIndent(drum_json))\n"
    "                    bank_json[\"instruments\"][\"percussion\"] = drums_list_json\n"
    "\n"
    "            # Instrument lists\n"
    "            for addr in bank.inst_list:\n"
    "                if addr is None:\n"
    "                    bank_json[\"instrument_list\"].append(None)\n"
    "                else:\n"
    "                    bank_json[\"instrument_list\"].append(addr_to_name[addr])\n"
    "\n"
    "            out.write(json.dumps(bank_json, indent=4, cls=NoIndentEncoder))\n"
    "            out.write(\"\\n\")\n"
    "\n"
    "\n"
    "if __name__ == \"__main__\":\n"
    "    main()\n"
    "\0"
};

#endif